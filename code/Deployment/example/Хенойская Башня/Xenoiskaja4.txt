#include "code\Deployment\Deployment.txt"

//----------------------------------------------------------------------------------------------
void main(){
	SYS=(map)0;
	Deployment(&SYS,"стартовое состо€ние",{{6,5,4,3,2,1},{},{},{}});
	Deployment(&SYS,"метод текстового описани€ состо€ни€","XtoString");
	//Deployment(&SYS,"разварачивать до первого конечного состо€ни€");
	Deployment(&SYS,"признак конечного состо€ни€","gotovo");
	Deployment(&SYS,"методы изменени€ состо€ни€",{"perebros"});
	Deployment(&SYS,"подготовка параметров к методам изменени€ состо€ни€",{"paramsForPerebros"});
	Deployment(&SYS,"включить отображение новых состо€ний"); //
	Deployment(&SYS,"им€ модели","Xenoi4x");
	//Deployment(&SYS,"врем€ ожидани€",60*15);
	Deployment(&SYS,"сохран€ть через каждых секунд",60*5);
	Deployment(&SYS,"номер версии",6);
	Deployment(&SYS,"файл задани€",getThisFileName());

	if(!Deployment(&SYS,"развернуть систему")){
		trace("ѕревышено врем€ ожидани€.");
		trace("ƒл€ продолжени€ разварачивани€ системы запустите программу повторно.");
		getstring();
		return;
		}
	if(Deployment(&SYS,"развЄртывание толькочто произошло")){
		trace("∆ми ≈Ќ“≈– дл€ выхода.");
		getstring();
		return;
		}
	trace("«агрузка развЄрнутой системы игровых состо€ний завершена.");

	Deployment(&SYS,"распечатка системы");
	trace();

	ways=Deployment(&SYS,"вз€ть все кратчайшие пути к конечному состо€нию");
	trace(" оличество возможных путей: "+ways.size());
	Deployment(&SYS,"распечатка состо€ний по заданному пути",ways[0]);
	trace();

	trace(
		"Ќа разворачивание системы ушло времени: " +
		Deployment(&SYS,"сколько времени ушло на разворачивание?")
		);

	getstring();
}


// ћетод дл€ подготовки параметров к методу изменени€ состо€ни€
var paramsForPerebros(S){
	v={};
	for(i=0;i<S->size();++i){
		iz=&(*S)[i];
		if(!iz->size())continue;
		for(t=0;t<S->size();++t)if(i!=t){
			ok=0;
			kuda=&(*S)[t];
			if(!kuda->size())ok=1;else if(kuda->end()>iz->end())ok=1;
			if(ok)v.push({i,t});
			}
		}
	return v;
}


// методы изменени€ состо€ни€
void perebros(S,iz,kuda){
	x=(*S)[iz].pop();
	(*S)[kuda].push(x);
}


// ¬ернет 1, когда цель достигнута
bool gotovo(S){
	return (*S)[1]=={6,5,4,3,2,1};
}


// ¬ернЄт строку, по которой видно положение фишок.
string XtoString(S){
	str="";
	for(i=0;i<S->size();++i){
		if(i)str+="|";
		ss="";
		for(t=0;t<(*S)[i].size();++t)ss+=(*S)[i][t];
		str+=ss.rovno(5);
		}
	return str;
}
