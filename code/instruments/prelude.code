// prelude.code

#include <code\instruments\ExportData.txt>



var arhiv(var command){
	command=command.trim();
	if(command[0]=='['&&command[command.size()-1]==']'){
		command=command.substr(1,command.size()-2);
		m=command.split(" ");
		if(m.size()==1)return reserve(((int)command));
		a=((int)m[0]);
		b=((int)m[2]);
		size=a-b;
		if(a<b)size=b-a;
		if(m[1]=="to")++size;
		R=reserve(size);
		i=0;
		for(;i<size;++i)R[i]=a<b?a+i:a-i;
		return R;
		}
}



var init(var command,var m){
	X=PROGRAM(command);
	names=((set)X.getNames());
	if(names.size()>1){
		trace("Error init: "+command.export());
		return m;
		}
	if(names.size()==1)X.replace(names[0],"i");
	i=0;
	for(;i<m.size();++i)m[i]=eval(X);
	return m;
}



var map(var command,var m){
	X=PROGRAM(command);
	names={};
	if(isset(X))names=((set)X.getNames());
	if(names.size()>1){
		trace("Error map: "+command.export());
		return m;
		}
	if(!names.size()){
		Y=PROGRAM("i"+command);
		if(isset(Y))X=Y;
		names=X.getNames();
		}
	if(names.size()==1){
		X.replace(names[0],"t");
		}
	i=0;
	for(;i<m.size();++i){
		t=m[i];
		m[i]=eval(X);
		}
	return m;
}



var integrate(var func,var args,var poverh){
	if(typeof(func)=="string")func=getFunction(func);
	func=func.copy();
	newNames=names=func.getNamesStart();
	size={names.size(),args.size()}.min();
	i=0;
	for(;i<size;++i)if(isset(args[i])){
		newNames-={names[i]};
		text=ExportDataSpeed(&args[i]);
		X=PROGRAM(names[i]+"="+text);
		pos=func.Root();
		pos=func.insertDown(pos);
		func.setCommand(pos,X);
		};
	func.setNamesStart(newNames);
	return func;
}


// prelude.code	:-|